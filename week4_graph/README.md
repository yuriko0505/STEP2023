# STEP第4週 Wikipedia探索アルゴリズム

## **宿題1**
- BFSを実装しました．
- 辞書型配列 ```prev_node``` を用意し，今見ているノード（keyとする）と1つ前に見ていたノード（valueとする）の組を格納するようにしました．こうすることで，ゴールからスタートまでをたどり返すことができ，最短経路を出せるようになりました．

## **宿題2**
(2023/06/11 時点)
- 更新前と更新後のページランクを格納しておく配列を用意しました．
- 全てのノードに等しく分配する処理は，分配されるページランクの合計値を ```dist_random``` に記録しておき最後にまとめて足すことで，計算時間が短縮されました．
- ```medium``` のページランク上位10個は次のようになりました:

<div style="text-align: center;">

| rank | ページ名 |
| ---: | :---: |
| 1 | 英語 |
| 2 | ISBN |
| 3 | 2006年 |
| 4 | 2005年 |
| 5 | 2007年 |
| 6 | 東京都 |
| 7 | 昭和 |
| 8 | 2004年 |
| 9 | 2003年 |
| 10 | 2000年 |

</div>


(2023/06/08 時点)
- ページランクの配列を作り，それに遷移行列（```Google_matrix```）をかけることでページランクの更新をしようと試みました．
- ```small``` では動きますが ```medium``` ではメモリの使いすぎで動きませんでした．メモリ過多の原因は遷移"行列"（メモリ量: $\mathcal{O} (N^2)$）と思われます．
- 遷移行列を配列として持たずにページランクの配列を2つ（更新前と後）用意し，ページ1から順に分配して足し合わせていくことをページ分行えば，更新の操作1回分が完了します．これを収束するまで何度も行えば，最終的なページランクが求まります．行列とベクトルの積よりは計算時間が長くかかると思われますが，使用メモリは $\mathcal{O} (N)$になります．
- 上記の方法で実装し直しているところです．